import java.util.ArrayList;
import java.util.List;

import java_cup.runtime.*;
import chocopy.common.astnodes.*;

/* The following code section is copied verbatim to the generated
 * parser class. */
parser code {:

    /* The following fields and methods deal with error reporting
     * Avoid changing these unless you know what you are doing. */

    /** Node that accumulates error messages to be added to the Program
     *  node produced as a result. */
    public final Errors errors = new Errors(new ArrayList<>());

    /** Return the Program node that results from parsing the stream of
     *  tokens produced by lexical analysis.  In the case of syntax errors,
     *  the program may be empty, but will have error messages. */
    public Program parseProgram(boolean debug) {
        try {
            Symbol result = debug ? debug_parse() : parse();
            if (result == null || !(result.value instanceof Program)) {
                return new Program(new Location(0, 0), new Location(0, 0),
                                   new ArrayList<Declaration>(),
                                   new ArrayList<Stmt>(),
                                   errors);
            } else {
                return (Program) result.value;
            }
        } catch (RuntimeException excp) {
            throw excp;
        } catch (Exception excp) {
            String msg =
                String.format("Internal parser error detected: %s%n", excp);
            throw new AssertionError(msg);
        }
    }

    @Override
    public SymbolFactory getSymbolFactory() {
        return ((ChocoPyLexer) getScanner()).symbolFactory;
    }

    @Override
    public void syntax_error(Symbol cur_token) {
                String token = symbl_name_from_id(cur_token.sym);
                String text = ((ChocoPyLexer) getScanner()).yytext();
                errors.syntaxError(
                    ((ComplexSymbolFactory.ComplexSymbol) cur_token).xleft,
                    ((ComplexSymbolFactory.ComplexSymbol) cur_token).xright,
                    "Parse error near token %s: %s", token, text);
    }

    @Override
    public void unrecovered_syntax_error(Symbol cur_token) {
        /* Do not die */
    }
:}


/**************************************************************************
 *              FEEL FREE TO MODIFY ANYTHING BELOW THIS LINE              
 *
 * The rules provided below parse expressions of the form <INT> + <INT> + ... 
 * You can re-use these rules or edit them as you wish. The start rule
 * should return a node of type Program.
 *
 * Tips: Production rules are usually followed by action code that will be
 * copied to the generated parser to be executed immediately after a reduce
 * operation; that is, when a production rule has been matched. You can name
 * a nonterminal or terminal symbol in a production rule using the colon
 * notation, e.g. expr_stmt ::= expr:e, to get the AST node for the matched
 * expression. In the action code, `e` will be a variable of whatever type
 * has been declared for the corresponding nonterminal, such as `Expr`.
 * Therefore, you can construct an AST Node of type `ExprStmt` with `e` in the
 * constructor: `new ExprStmt(exleft, exright, e)`
 *
 * The variables `exleft` and `exright` are automatically generated by CUP
 * and contain Location objects for the start and end of the expression `e`.
 * You can collect start and line number info for AST nodes by taking the
 * location of the left end of the leftmost symbol in a rule and the
 * location of the right end of the rightmost symbol. The auto-generated
 * variables have names `<sym>xleft` and `<sym>xright`, where <sym> is the
 * name given to the symbol using the colon notation.
 *
 * When you have nonterminals that are lists of things, e.g. List<Stmt> or
 * List<Declaration>, it is helpful to get the leftmost and rightmost
 * source location from within this list; we have provided some utility
 * functions below to do just that.
 **************************************************************************/


action code {:

    <T> List<T> single(T item) {
        List<T> list = new ArrayList<>();
        if (item != null) {
            list.add(item);
        }
        return list;
    }

    <T> List<T> combine(List<T> list, T item) {
        if (item != null) {
            list.add(item);
        }
        return list;
    }

    /** Se ITEM não for nulo, adiciona-o ao início da LISTA. Em seguida, retorna
     *  a LISTA. */
    <T> List<T> combine(T item, List<T> list) {
        if (item != null) {
            list.add(0, item);
        }
        return list;
    }

    <T> List<T> empty() {
        return new ArrayList<T>();
    }

    ComplexSymbolFactory.Location getLeft(List<? extends Node> nodes) {
        if (nodes.isEmpty()) {
            return null;
        }
        Node first = nodes.get(0);
        return new ComplexSymbolFactory.Location(first.getLocation()[0],
                                                 first.getLocation()[1]);
    }

    /** Retorna a loc mais à direita que não seja espaço em branco em NODES, ou null se
     *  NODES estiver vazio. Assume que os nós de NODES estão ordenados em
     *  ordem crescente de loc, da esquerda para a direita. */
    ComplexSymbolFactory.Location getRight(List<? extends Node> nodes) {
        if (nodes.isEmpty()) {
            return null;
        }
        Node last = nodes.get(nodes.size() - 1);
        return new ComplexSymbolFactory.Location(last.getLocation()[2],
                                                 last.getLocation()[3]);
    }
:}


terminal String IDENTIFIER, STRING, IDSTRING;
terminal String PLUS, MINUS, TIMES, DIVIDE, MOD;
terminal String LESSTHAN, GREATERTHAN, LESSEQ, GREATEREQ;
terminal String EQEQ, NOTEQ, EQ;
terminal String LPAREN, RPAREN, LBRACKET, RBRACKET;
terminal String COMMA, COLON, DOT, ARROW;
terminal String IS;
terminal Integer INTEGER;

terminal NEWLINE;
terminal INDENT, DEDENT;
terminal FALSE, NONE, TRUE, AND, AWAIT;
terminal BREAK, CLASS, CONTINUE, DEF, ELIF, ELSE;
terminal NONLOCAL, FOR, FROM, GLOBAL, IF, IMPORT;
terminal IN, NOT, OR, PASS, RAISE;
terminal RETURN, TRY, WHILE;
terminal UMINUS;
terminal UNRECOGNIZED;

non terminal Program            root;
non terminal List<Declaration>  decl_seq;
non terminal List<Stmt>         command_seq0, command_seq1;
non terminal Identifier         ident;
non terminal ClassDef           class_decl;
non terminal List<Declaration>  class_content, class_content_list1;
non terminal FuncDef            func_decl;
non terminal List<Declaration>  func_content;
non terminal List<TypedVar>     param_list, typed_param_list;
non terminal TypeAnnotation     type_annot;
non terminal TypedVar           typed_ident;
non terminal GlobalDecl         global_var;
non terminal NonLocalDecl       nonlocal_var;
non terminal VarDef             var_decl;
non terminal Stmt               command, simple_command;
non terminal List<Stmt>         else_part, block_part;
non terminal List<Expr>         expr_seq1, target_seq1;
non terminal Literal            const_val;
non terminal Expr               expression, cexpression, target_expr;
non terminal MemberExpr         member_access;
non terminal IndexExpr          array_access;

/* Precedências (da menor para a maior) para resolver ambiguidades que causariam
 * conflitos de shift/reduce/etc */
precedence nonassoc IF, ELSE;
precedence left OR;
precedence left AND;
precedence left NOT;
precedence nonassoc EQEQ, NOTEQ,
     LESSTHAN, GREATERTHAN, LESSEQ, GREATEREQ, IS;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MOD;
precedence left UMINUS;
precedence nonassoc DOT, LBRACKET, RBRACKET;

start with root;

/*****  GRAMMAR RULES *****/

/* Regras gramaticais do ChocoPy */
root ::= decl_seq:d command_seq0:s
      /* Gera nó Program com sequências de declarações e comandos */
      {: RESULT = new Program(d.isEmpty() ? getLeft(s) : getLeft(d),
                  getRight(s), d, s, errors);
      :}
      ;

/* Sequência de declarações no nível raiz */
decl_seq ::=                        /* Lista vazia inicial */
         {: RESULT = empty(); :}
       | decl_seq:d var_decl:x   /* Adiciona variável */
       {: RESULT = combine(d, x); :}
       | decl_seq:d func_decl:x  /* Adiciona função */
       {: RESULT = combine(d, x); :}
       | decl_seq:d class_decl:x /* Adiciona classe */
       {: RESULT = combine(d, x); :}
       ;

command_seq0 ::=                    /* Sequência vazia */
         {: RESULT = empty(); :}
       | command:x command_seq0:l /* Adiciona comando */
         {: RESULT = combine(x, l); :}
       | error command_seq0:l    /* Ignora erro */
         {: RESULT = l; :}
       ;

ident ::= IDENTIFIER:id           /* Identificador básico */
     {: RESULT = new Identifier(idxleft, idxright, id); :}
   ;
      
class_decl ::= CLASS:kw ident:name LPAREN ident:parent RPAREN COLON NEWLINE INDENT class_content:content DEDENT 
              /* Define estrutura de classe */
              {: RESULT = new ClassDef(kwxleft, getRight(content), name, parent, content);:}
            ;

class_content ::= PASS NEWLINE          /* Classe vazia */
         {: RESULT = empty(); :}
       | class_content_list1:items /* Lista de membros */
         {: RESULT = items; :}
       ;
      
class_content_list1 ::= var_decl:var    /* Variável de classe */
             {: RESULT = single(var); :}
             | func_decl:method /* Método de classe */
             {: RESULT = single(method); :}
             | class_content_list1:items var_decl:var /* Mais variáveis */
             {: RESULT = combine(items, var); :}
             | class_content_list1:items func_decl:method /* Mais métodos */
             {: RESULT = combine(items, method); :}
             ;
          
func_decl ::= DEF:def ident:name LPAREN param_list:params RPAREN COLON:colon NEWLINE INDENT func_content:content command_seq1:body DEDENT
             /* Função sem tipo de retorno */
             {: ClassType ret_type = new ClassType(colonxleft, colonxright, "<None>");
                RESULT = new FuncDef(defxleft, getRight(body), 
                                    name, params, ret_type, content, body); 
             :}
           | DEF:def ident:name LPAREN param_list:params RPAREN ARROW type_annot:ret_type COLON NEWLINE INDENT func_content:content command_seq1:body DEDENT
             /* Função com tipo de retorno */
             {: RESULT = new FuncDef(defxleft, getRight(body), 
                                    name, params, ret_type, content, body); 
             :}
           ;

param_list ::=                     /* Sem parâmetros */
       {: RESULT = empty(); :}
     | typed_param_list:params     /* Lista de parâmetros */
       {: RESULT = params; :}
     ;    

typed_param_list ::= typed_ident:param /* Único parâmetro */
        {: RESULT = single(param); :}
        | typed_param_list:params COMMA typed_ident:param /* Múltiplos parâmetros */
        {: RESULT = combine(params, param); :}
        ;

func_content ::=                      /* Conteúdo vazio */
            {: RESULT = empty(); :}
            | func_content:items global_var:var /* Variável global */
            {: RESULT = combine(items, var); :}
            | func_content:items nonlocal_var:var /* Variável não-local */
            {: RESULT = combine(items, var); :}
            | func_content:items var_decl:var /* Variável local */
            {: RESULT = combine(items, var); :}
            | func_content:items func_decl:func /* Função interna */
            {: RESULT = combine(items, func); :}
            ;

command_seq1 ::= command:cmd                /* Comando único */
         {: RESULT = single(cmd); :}
       | command_seq1:seq command:cmd     /* Sequência de comandos */
         {: RESULT = combine(seq, cmd); :}
       ;

typed_ident ::= ident:name COLON type_annot:type      
              /* Identificador com tipo */
              {: RESULT = new TypedVar(namexleft, typexright,
                                       name, type);
              :}
            ;

type_annot ::= IDENTIFIER:type           
         /* Tipo de classe */
         {: RESULT = new ClassType(typexleft, typexright, type); :}    
       | IDSTRING:type              
         /* Tipo de string */
         {: RESULT = new ClassType(typexleft, typexright, type); :}
       | LBRACKET:lb type_annot:elem RBRACKET:rb     
         /* Tipo de lista */
         {: RESULT = new ListType(lbxleft, rbxright, elem); :}
       ;

global_var ::= GLOBAL:kw ident:name NEWLINE
                /* Variável global */
                {: RESULT = new GlobalDecl(kwxleft, namexright, name); :}
                ;

nonlocal_var ::= NONLOCAL:kw ident:name NEWLINE
                  /* Variável não-local */
                  {: RESULT = new NonLocalDecl(kwxleft, namexright, name); :}
                ;

var_decl ::= typed_ident:var EQ const_val:val NEWLINE
            /* Declaração de variável */
            {: RESULT = new VarDef(varxleft, valxright,
                                   var, val);
            :}
          ;
        
command ::= simple_command:cmd NEWLINE
         /* Comando básico */
         {: RESULT = cmd; :}
       | IF:if_kw expression:cond COLON block_part:then else_part:else_part
         /* Estrutura condicional */
         {: Location right = then.isEmpty() ? condxright : getRight(then);
            right = else_part.isEmpty() ? right : getRight(else_part);
            RESULT = new IfStmt(if_kwxleft, right,
                                cond, then, else_part);
         :}
       | WHILE:while_kw expression:cond COLON:colon block_part:body
         /* Laço while */
         {: RESULT = new WhileStmt(while_kwxleft, body.isEmpty() ? colonxright : getRight(body), 
                                   cond, body);
         :}
       | FOR:for_kw ident:iter IN expression:seq COLON:colon block_part:body
         /* Laço for */
         {: RESULT = new ForStmt(for_kwxleft, body.isEmpty() ? colonxright : getRight(body), 
                                  iter, seq, body);
         :}
       ;

else_part ::=                    /* Sem else */
         {: RESULT = empty(); :}
       | ELSE COLON block_part:body /* Bloco else */
         {: RESULT = body; :}
       | ELIF:elif_kw expression:cond COLON block_part:then else_part:else_part
         /* Bloco elif */
         {: Location right = then.isEmpty() ? condxright : getRight(then);
            right = else_part.isEmpty() ? right : getRight(else_part);
            IfStmt ifStmt = new IfStmt(elif_kwxleft, right,
                                       cond, then, else_part);
            RESULT = single(ifStmt);                  
         :}
       ;

simple_command ::= PASS           /* Comando vazio */
                {: RESULT = null; :}
              | expression:expr     /* Expressão como comando */
                {: RESULT = new ExprStmt(exprxleft, exprxright, expr); :}
              | RETURN:ret expression:val /* Retorno com valor */
                {: RESULT = new ReturnStmt(retxleft, valxright, val); :}
              | RETURN:ret         /* Retorno sem valor */
                {: RESULT = new ReturnStmt(retxleft, retxright, null); :}
              | target_seq1:targets expression:val   
                /* Atribuição */
                {: RESULT = new AssignStmt(getLeft(targets), valxright, targets, val); :}
              ;

target_seq1 ::= target_expr:target EQ /* Alvo único */
         {: RESULT = single(target); :}
         | target_seq1:targets target_expr:target EQ
         /* Múltiplos alvos */
         {: RESULT = combine(targets, target); :}
         ;
    
block_part ::= NEWLINE INDENT command_seq1:cmds DEDENT
          /* Bloco indentado */
          {: RESULT = cmds; :}
        ;

const_val ::= NONE:val         /* Valor nulo */
          {: RESULT = new NoneLiteral(valxleft, valxright); :}
          | TRUE:val         /* Valor booleano true */
          {: RESULT = new BooleanLiteral(valxleft, valxright, true); :}
          | FALSE:val        /* Valor booleano false */
          {: RESULT = new BooleanLiteral(valxleft, valxright, false); :}
          | INTEGER:val      /* Valor inteiro */
          {: RESULT = new IntegerLiteral(valxleft, valxright, val); :}
          | IDSTRING:val     /* String identificadora */
          {: RESULT = new StringLiteral(valxleft, valxright, val); :}
          | STRING:val       /* String literal */
          {: RESULT = new StringLiteral(valxleft, valxright, val); :}
          ;

expression ::= cexpression:expr   /* Expressão composta */
       {: RESULT = expr; :}
       | NOT:op expression:val    /* Negação lógica */
         {: RESULT = new UnaryExpr(opxleft, valxright, "not", val); :}
       | expression:left AND expression:right /* Conjunção */
         {: RESULT = new BinaryExpr(leftxleft, rightxright, left, "and", right); :}
       | expression:left OR expression:right  /* Disjunção */
         {: RESULT = new BinaryExpr(leftxleft, rightxright, left, "or", right); :}
       | cexpression:then IF expression:cond ELSE expression:else_val
         /* Expressão condicional */
         {: RESULT = new IfExpr(thenxleft, else_valxright, cond, then, else_val); :}
       ;

cexpr ::= id:id                 /* Uma expressão básica que é apenas um identificador. */
        {: RESULT = id; :}
        | literal:liter         /* Ou um literal (número, string, etc.). */
          {: RESULT = liter; :}
        | LBRACKET RBRACKET     /* Ou uma lista vazia. */
          {: RESULT = null; :}
        | LBRACKET:lb expr_list1:l RBRACKET:rb
          /* Constrói um nó ListExpr a partir de uma lista de expressões. */
          {: RESULT = new ListExpr(lbxleft, rbxright, l); :}
        | LPAREN expr:e RPAREN  /* Ou uma expressão entre parênteses. */
          {: RESULT = e; :}
        | member_expr:e         /* Ou um acesso a membro. */
          {: RESULT = e; :}
        | index_expr:e          /* Ou um acesso via índice. */
          {: RESULT = e; :}
        | member_expr:e LPAREN RPAREN:rb
          /* Constrói um nó MethodCallExpr para uma chamada de método sem argumentos. */
          {: RESULT = new MethodCallExpr(exleft, rbxright, e, empty()); :}
        | member_expr:e LPAREN expr_list1:l RPAREN:rb
          /* Constrói um nó MethodCallExpr para uma chamada de método com argumentos. */
          {: RESULT = new MethodCallExpr(exleft, rbxright, e, l); :}
        | id:id LPAREN RPAREN:rb
          /* Constrói um nó CallExpr para uma chamada de função sem argumentos. */
          {: RESULT = new CallExpr(idxleft, rbxright, id, empty()); :}
        | id:id LPAREN expr_list1:l RPAREN:rb
          /* Constrói um nó CallExpr para uma chamada de função com argumentos. */
          {: RESULT = new CallExpr(idxleft, rbxright, id, l); :}
        | cexpr:e1 PLUS:op cexpr:e2
          /* Constrói um nó BinaryExpr para a soma. */
          {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
        | cexpr:e1 MINUS:op cexpr:e2
          /* Constrói um nó BinaryExpr para a subtração. */
          {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
        | cexpr:e1 TIMES:op cexpr:e2
          /* Constrói um nó BinaryExpr para a multiplicação. */
          {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
        | cexpr:e1 DIVIDE:op cexpr:e2
          /* Constrói um nó BinaryExpr para a divisão. */
          {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
        | cexpr:e1 MOD:op cexpr:e2
          /* Constrói um nó BinaryExpr para o operador módulo. */
          {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
        | cexpr:e1 EQEQ:op cexpr:e2
          /* Constrói um nó BinaryExpr para a comparação de igualdade. */
          {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
        | cexpr:e1 NOTEQ:op cexpr:e2
          /* Constrói um nó BinaryExpr para a comparação de desigualdade. */
          {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
        | cexpr:e1 LESSEQ:op cexpr:e2
          /* Constrói um nó BinaryExpr para a comparação de menor ou igual. */
          {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
        | cexpr:e1 LESSTHAN:op cexpr:e2
          /* Constrói um nó BinaryExpr para a comparação de menor que. */
          {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
        | cexpr:e1 GREATEREQ:op cexpr:e2
          /* Constrói um nó BinaryExpr para a comparação de maior ou igual. */
          {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
        | cexpr:e1 GREATERTHAN:op cexpr:e2
          /* Constrói um nó BinaryExpr para a comparação de maior que. */
          {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
        | cexpr:e1 IS:op cexpr:e2
          /* Constrói um nó BinaryExpr para a comparação de identidade (IS). */
          {: RESULT = new BinaryExpr(e1xleft, e2xright, e1, op, e2); :}
        | MINUS:minus cexpr:e 
          /* Constrói um nó UnaryExpr para a negação. */
          {: RESULT = new UnaryExpr(minusxleft, exright, "-", e); :}
          %prec UMINUS
        ;
    
/* Produção para uma lista de expressões separadas por vírgula. */
expr_list1 ::= expr:e           /* Retorna uma lista com uma única expressão. */
             {: RESULT = single(e); :}
             | expr_list1:l COMMA expr:e
               /* Combina uma lista existente com uma nova expressão. */
               {: RESULT = combine(l, e); :}
             ;

/* Produção para acesso a membros, por exemplo, objeto.identificador. */
member_expr ::= cexpr:e DOT id:id
                /* Cria um nó MemberExpr com o objeto e o membro. */
                {: RESULT = new MemberExpr(exleft, idxright, e, id); :}
              ;

/* Produção para acesso via índice, por exemplo, objeto[expressão]. */
index_expr ::= cexpr:e1 LBRACKET expr:e2 RBRACKET:rb
               /* Cria um nó IndexExpr com o objeto e o índice. */
               {: RESULT = new IndexExpr(e1xleft, rbxright, e1, e2); :}
             ;

/* Produção para um alvo (target) de atribuição, que pode ser um identificador,
   um acesso a membro ou um acesso via índice. */
target ::= id:id            /* Um identificador simples. */
         {: RESULT = id; :}
         | member_expr:e    /* Ou um acesso a membro. */
           {: RESULT = e; :}
         | index_expr:e     /* Ou um acesso via índice. */
           {: RESULT = e; :}
         ;
